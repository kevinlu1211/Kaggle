?lda
lda.fit$svd
prediction <- predict(lda.fit, train_test)
head(prediction)
head(prediction$class)
head(prediction$class)[1]
crossValidate.lda<- function(fit, test) {
actual <- array(test[,"Survived"])
predicted <- predict(fit, test)$class
correctCount <- 0
for(i in 1:length(predicted)) {
if(predicted[i] == actual[i]) {
correctCount <- correctCount + 1
}
}
print("Number of correct classifications:")
print(correctCount)
print("Number of samples:")
print(nrow(test))
accuracy <- correctCount/nrow(test)
return(accuracy)
}
print(crossValidate.lda(lda.fit, train_test))
A <- matrix(c(3,4,1,7),2,2,byrow=TRUE)
A
y <- matrix(c(9,10),2,1)
y
eigen(A)
solve(A,)
solve(A,y)
3*1.35 + 4*1.23
eigen(A)
?eigen
A
eigens <- eigen(A)
A %*% eigens$vectors[1,]
eigens$vectors[1,] * eigens$value[1]
eigens$vectors[1,]
eigens$vectors[,1] * eigens$value[1]
A %*% eigens$vectors[,1]
B <- matrix(c(5),1,1)
B
eigen(B)
eigen(B)
B
A
A
eigen(A)
set.seed(2)
x <- 1:100
y <- 20 + 3 * x
e <- rnorm(100, 0, 60)
y <- y + e
y
rnorm(100)
rnorm(50)
plot(x,y)
yx.lm(y~x)
yx.lm <- lm(y~x)
lines(x, predict(yx.lm), col="red")
df <- data.frame(x,y)
p1 <- ggplot(df, aes(x=x, y=y))
p1 + gg_point()
p1 + geom_point()
p1 + geom_point() + geom_line()
?geom_line()
p1 + geom_point() + geom_line(aes(y=predict(yx.lm, x))
)
p1 + geom_point() + geom_line(aes(y=predict(yx.lm, x)))
xy.lm <- lm(x~y)
set.seed(2)
x <- 1:100
y <- 20 + 3 * x
e <- rnorm(100, 0, 60)
y <- y + e
plot(x,y)
yx.lm <- lm(y~x)
lines(x, predict(yx.lm), col="red")
xy.lm <- lm(x~y)
lines(x, predict(xy/lm), col="blue")
lines(x, predict(xy.lm), col="blue")
xy.lm <- lm(x~y)
set.seed(2)
x <- 1:100
y <- 20 + 3 * x
e <- rnorm(100, 0, 60)
y <- y + e
plot(x,y)
yx.lm <- lm(y~x)
lines(x, predict(yx.lm), col="red")
xy.lm <- lm(x~y)
lines(x, predict(xy.lm), col="blue")
set.seed(2)
x <- 1:100
y <- 20 + 3 * x
e <- rnorm(100, 0, 60)
y <- y + e
plot(x,y)
yx.lm <- lm(y~x)
lines(x, predict(yx.lm), col="red")
xy.lm <- lm(x~y)
lines(x, predict(xy.lm), col="blue")
lines(y, predict(xy.lm), col="blue")
predict(xy.lm)
y
y[1]
predict(xy.lm)[1]
cor(predict(xy.lm), y)
set.seed(2)
x <- 1:100
y <- 20 + 3 * x
e <- rnorm(100, 0, 60)
y <- y + e
plot(x,y)
yx.lm <- lm(y~x)
lines(x, predict(yx.lm), col="red")
xy.lm <- lm(x~y)
lines(predict(xy.lm), y, col="blue")
xyNorm <- cbind(x = x - mean(x), y = y - mean(y))
plot(xyNorm)
plot(x,y)
plot(xyNorm)
plot(x,y)
plot(xyNorm)
xyCov <- cov(xyNorm)
xyCov
df <- data.frame(x,y)
plot(df)
cov(df)
eigenValues <- eigen(xyCov)$values
eigenVectors <- eigen(xyCov)$vectors
plot(xyNorm, ylim=c(-200,200), xlim=c(-200,200))
plot(xyNorm)
plot(xyNorm, ylim=c(-200,200), xlim=c(-200,200))
xyNorm[x]
lines(xyNorm[x], eigenVectors[2,1]/eigenVectors[1,1] * xyNorm[x])
eigenVectors[2,1]
eigenVectors
lines(xyNorm[x], eigenVectors[2,2]/eigenVectors[1,2] * xyNorm[x])
plot(xy)
plot(x,y)
lines(x, (eigenVectors[2,1]/eigenVectors[1,1] * xyNorm[x]) + mean(y))
lines(x, predict(yx.lm), col=”red”)
lines(predict(xy.lm), y, col=”blue”)
lines(x, predict(yx.lm), col='red')
lines(predict(xy.lm), y, col='blue')
cov(x,y)
df <- data.frame(x,y)
df
cov(df)
cov(x,y)
eigenVectors <- eigen(df)$vectors
sigma
sigma <- cov(df)
eigenVectors <- eigen(sigma)$vectors
eigenValues <- eigen(sigma)$values
eigenVectors
eigenValues
eigenVectors[1]/sum(eigenVectors)
eigenValues[1]/sum(eigenValues)
eigenVector[1]
eigenVector
eigenVectors
t(eigenVectors[,1])
x
summary(yx.lm)
data("heptathlon", package = "HSAUR")
install.packages("HSAUR")
data("heptathlon", package = "HSAUR")
heptathlon$hurdles <- max(heptathlon$hurdles) - heptathlon$hurdles
str(heptathlon)
data("heptathlon", package = "HSAUR")
str(heptathlon)
heptathlon_pca <- prcomp(heptathlon[,-score], scale = TRUE)
heptathlon_pca <- prcomp(heptathalon[,-score], scale = TRUE)
str(heptathlon)
heptathlon_pca <- prcomp(heptathlon[,-score], scale = TRUE)
heptathlon_pca <- prcomp(heptathlon[,-"score"], scale = TRUE)
heptathlon_pca <- prcomp(heptathlon[, -score], scale = TRUE)
heptathlon_pca <- prcomp(heptathlon[, -score], scale = TRUE)
heptathlon[,-1]
heptathlon[,-2]
heptathlon[,-hurdles]
heptathlon_pca <- prcomp(heptathlon[, ncol(heptathlon)], scale = TRUE)
print(heptathlon_pca)
score <- which(colnames(heptathlon) == "score")
score
score <- which(colnames(heptathlon) == "score")
heptathlon_pca <- prcomp(heptathlon[, -score], scale = TRUE)
print(heptathlon_pca)
print(heptathlon_pca)
heptathlon_pca <- prcomp(heptathlon[, -score], scale = TRUE)
print(heptathlon_pca)
plot(heptathlon[,-score])
summary(heptathlon_pca)
a1 <- heptathlon_pca$rotation[,1]
a1
center <- heptathlon_pca$center
center
str(heptathlon)
center
scale <- heptathlon_pca$scale
scale
var(heptathlon$hurdles)
sqrt(var(heptathlon$hurdles))
hm <- as.matrix(heptathlon[,-score])
?drop
scale(hm, center = center)
scale(hm, center = center)
hm
head(hm)
head(hm)
hm <- as.matrix(heptathlon[,-score])
head(hm)
hm1 <- scale(hm, center = center)
head(hm1)
hm1 <- scale(hm, center = center, scale = scale)
head(hm1)
center[1]
scale[1]
(12.69 - center[1]) / scale[1]
dim(hm1)
dim(a1)
length(a1)
new_x <- hm1 %*% a1
new_x
new_x <- drop(hm1 %*% a1)
new_x
original_x <- new_x %*% solve(ai)
new_x <- h1 %*% ai
new_x <- hm1 %*% a1
new_x
original_x <- new_x %*% solve(a1)
t(a1) %*% t(hm1)
new_x
t(a1) %*% t(hm1)
cor(t(a1) %*% t(hm1), new_x)
dim(new_x)
dim(t(a1) %*% t(hm1))
cor(t(new_x), t(a1) %*% t(hm1))
new_x
str(heptathlon)
summary(heptathlon_pca)
original_x <- solve(t(a1)) %*%t(hm)
x <- matrix(c(1,2)1,2)
x <- matrix(c(1,2),1,2)
x
solve(x)
original_x <- a1 %*% new_x
a1
dim(new_x)
dim(a1)
#Generate data
m=50
n=100
frac.gaps <- 0.5 # the fraction of data with NaNs
N.S.ratio <- 0.25 # the Noise to Signal ratio for adding noise to data
x <- (seq(m)*2*pi)/m
t <- (seq(n)*2*pi)/n
#True field
Xt <-
outer(sin(x), sin(t)) +
outer(sin(2.1*x), sin(2.1*t)) +
outer(sin(3.1*x), sin(3.1*t)) +
outer(tanh(x), cos(t)) +
outer(tanh(2*x), cos(2.1*t)) +
outer(tanh(4*x), cos(0.1*t)) +
outer(tanh(2.4*x), cos(1.1*t)) +
tanh(outer(x, t, FUN="+")) +
tanh(outer(x, 2*t, FUN="+"))
Xt
outer(sin(x), sin(t))
plot(Xt)
head(Xt)
dim(Xt)
Xt <- t(Xt)
res <- prcomp(Xt, center = TRUE, scale = FALSE)
names(res)
res$x
head(res$x)
?prcomp
summary(res)
trunc <- res$x[,1:pc.use] %*% t(res$rotation[,1:pc.use])
pc.use <- 3
trunc <- res$x[,1:pc.use] %*% t(res$rotation[,1:pc.use])
res <- prcomp(Xt, center = TRUE, scale = TRUE)
names(res)
# this is our new x
head(res$x)
# we see that the first 3 PC's explain 93% of the variance
summary(res)
pc.use <- 3
summary(res)
res <- prcomp(Xt, center = TRUE, scale = FALSE)
names(res)
# this is our new x
head(res$x)
# we see that the first 3 PC's explain 93% of the variance
summary(res)
res <- prcomp(Xt, center = TRUE, scale = TRUE)
names(res)
head(res$x)
# we see that the first 3 PC's explain 93% of the variance
summary(res)
res <- prcomp(Xt, center = TRUE, scale = FALSE)
names(res)
# this is our new x
head(res$x)
# we see that the first 3 PC's explain 93% of the variance
summary(res)
pc.use <- 3
trunc <- res$x[,1:pc.use] %*% t(res$rotation[,1:pc.use])
res$scale
# scale the data back to the original axis
if(res$scale != FALSE){
trunc <- scale(trunc, center = FALSE , scale=1/res$scale)
}
if(res$center != FALSE){
trunc <- scale(trunc, center = -1 * res$center, scale=FALSE)
}
#Generate data
m=50
n=100
frac.gaps <- 0.5 # the fraction of data with NaNs
N.S.ratio <- 0.25 # the Noise to Signal ratio for adding noise to data
x <- (seq(m)*2*pi)/m
t <- (seq(n)*2*pi)/n
#True field
Xt <-
outer(sin(x), sin(t)) +
outer(sin(2.1*x), sin(2.1*t)) +
outer(sin(3.1*x), sin(3.1*t)) +
outer(tanh(x), cos(t)) +
outer(tanh(2*x), cos(2.1*t)) +
outer(tanh(4*x), cos(0.1*t)) +
outer(tanh(2.4*x), cos(1.1*t)) +
tanh(outer(x, t, FUN="+")) +
tanh(outer(x, 2*t, FUN="+"))
Xt <- t(Xt)
# PCA
res <- prcomp(Xt, center = TRUE, scale = FALSE)
names(res)
# this is our new x
head(res$x)
# we see that the first 3 PC's explain 93% of the variance
summary(res)
pc.use <- 3
trunc <- res$x[,1:pc.use] %*% t(res$rotation[,1:pc.use])
# scale the data back to the original axis
if(res$scale != FALSE){
trunc <- scale(trunc, center = FALSE , scale=1/res$scale)
}
if(res$center != FALSE){
trunc <- scale(trunc, center = -1 * res$center, scale=FALSE)
}
res$center
#Generate data
m=50
n=100
frac.gaps <- 0.5 # the fraction of data with NaNs
N.S.ratio <- 0.25 # the Noise to Signal ratio for adding noise to data
x <- (seq(m)*2*pi)/m
t <- (seq(n)*2*pi)/n
#True field
Xt <-
outer(sin(x), sin(t)) +
outer(sin(2.1*x), sin(2.1*t)) +
outer(sin(3.1*x), sin(3.1*t)) +
outer(tanh(x), cos(t)) +
outer(tanh(2*x), cos(2.1*t)) +
outer(tanh(4*x), cos(0.1*t)) +
outer(tanh(2.4*x), cos(1.1*t)) +
tanh(outer(x, t, FUN="+")) +
tanh(outer(x, 2*t, FUN="+"))
Xt <- t(Xt)
# PCA
res <- prcomp(Xt, center = TRUE, scale = FALSE)
names(res)
# this is our new x
head(res$x)
# we see that the first 3 PC's explain 93% of the variance
summary(res)
pc.use <- 3
trunc <- res$x[,1:pc.use] %*% t(res$rotation[,1:pc.use])
# scale the data back to the original axis
if(res$scale != FALSE){
trunc <- scale(trunc, center = FALSE , scale=1/res$scale)
}
if(res$center != FALSE){
print("hi")
trunc <- scale(trunc, center = -1 * res$center, scale=FALSE)
}
dim(trunc)
dim(Xt)
trunc <- res$x[,1:pc.use] %*% t(res$rotation[,1:pc.use])
dim(trunc)
dim(res$x)
x
Xt
dim(res$x[,1:pc.use])
Xt-mean(Xt)
Xt-mean(Xt)[1]
dim(Xt)
dim(res$x,1:pc.use)
dim(res$x[,1:pc.use])
head(dim(Xt))
head(Xt)
head(Xt,1)
head(Xt,1,1)
head(Xt)
head(Xt)[1]
head(Xt)[1]
head(res$x[1,1])[1]
head(Xt)
Xt[1,1:3]
res$x[1,1:3]
mean(X1[,1])
Xt[,1]
mean(Xt[,1])
Xt
cov(Xt)
eigen(cov(Xt))
eigen(cov(Xt))$values
eigen(cov(Xt))$vectors[1]
eigen(cov(Xt))$vectors
dim(eigen(cov(Xt))$vectors)
eigen(cov(Xt))$vectors[,1]
a <- eigen(cov(Xt))$vectors[,1]
dim(res$rotation)
b <- res$rotation[,1]
cor(a,b)
a
b
a <- eigen(cov(Xt))$vectors[,12]
b <- res$rotation[,12]
a
b
cor(a,b)
a
b
a <- eigen(cov(Xt))$vectors[,2]
b <- res$rotation[,2]
a
b
cor(a,b)
dim(res$x)
dim(Xt)
res$x
res$x[1]
res$x[1,]
res$x
head(res$x)
head(res$x)[1,]
res$rotation
magnitude
mog
mag
norm_vec <- function(x) sqrt(sum(x^2))
norm_vec(res$rotation[,1])
norm_vec(res$rotation[,2])
norm_vec(res$rotation[,4])
a
b
norm_vec(a)
norm_vec(b)
a <- eigen(cov(Xt))$vectors[,1]
a
?eigen
Xt_scale <- scale(Xt, center = res$center, scale = FALSE)
Xt_scale %*% res$rotation
dim(Xt_scale %*% res$rotation)
dim(res$x)
Xt_scale %*% res_rotation[1,1:3]
(Xt_scale %*% res$rotation)[1,1:3]
res$x[1, 1:3]
dim(res$x)
Xt_scale_projected <- res$x[,1:pc.use]
Xt_scale_reconstructed <- Xt_scale_projected %*% t(res$rotation[,1:pc.use])
cor(Xt_scale_reconstructed, Xt)
dim(res$x)
dim(Xt)
res1 <- prcomp(Xt, center=FALSE, scale = FALSE)
res1
norm
norm(1)
res1$x %*% t(res1$rotation)
norm(Xt - res1$x %*% t(res1$rotation))
?norm
norm
a <- norm(Xt)
str(a)
a
(Xt_scale %*% res$rotation)[1,1:3]
res$x[1, 1:3]
Xt[1,1]
b <- (Xt - res1$x %*% t(res1$rotation))
a
b
a
Xt[1,1]
b
b[1,1]
b <- (res1$x %*% t(res1$rotation))
b[1,1]
Xt[1,1]
Xt[1:10,1]
Xt[1:10,1]
Xt_scale_reconstructed <- Xt_scale_projected %*% t(res$rotation[,1:pc.use])
dim(Xt)
?prcomp
dim(Xt_scale_projected)
dim(Xt_scale_reconstructed)
